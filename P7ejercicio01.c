#include "P7ejercicio01.h"

#include <stdlib.h> //INCLUYE LA BIBIOTECA stdlib.h; PARA EL MANEJO DE LA MEMORIA DINÁMICA
#include <stdio.h>  //INCLUYE LA BIBIOTECA stdio.h; PARA LEER E IMPRIMIR DATOS DE TECLADO

nodo* crear_nodo(INFO info)     // FUNCIÓN crear_nodo PARA RESERVAR MEMORIA PARA UN NODO. PARÁMETROS: VARIABLE TIPO INFO. RETORNA UN APUNTADOR TIPO nodo
{
    nodo *t=(nodo*)malloc(sizeof(nodo));    //DECLARA UNA VARIABLE APUNTADOR TIPO nodo Y RESERVA MEMORIA CON LA FUNCIÓN malloc
    t->sig=NULL;    //IGUALA EL APUNTADOR AL NODO SIGUIENTE A NULO;
    t->info=info;   //IGUALA LA INFORMACIÓN DEL NODO AL PARÁMETRO QUE RECIVE LA INFORMACIÓN
    return t;   //RETORNA EL APUNTADOR DEL NODO
}

void liberar_nodo(nodo *n)  //FUNCIÓN liberar_nodo PARA LIBERAR MEMORIA DE UN NODO. PARÁMETROS: APUNTADOR TIPO nodo
{
    if(n->sig==NULL)    //CONDICIÓN PARA LIBERAR MEMORIA DEL NODO;
    {
        free(n);    //FUNCIÓN FREE PARA LIBERAR LA MEMORIA DEL NODO
        n=NULL; //LA VARIBLE APUNTA A NULO
    }
}

pila* crear_pila()  //FUNCIÓN crear_pila PARA CREAR/RESERVAR MEMORIA DE UNA PILA
{
    pila *l=(pila*)malloc(sizeof(pila));    //RESERVA MEMORIA PARA LA VARIABLE APUNTADOR TIPO pila CON LA FUCIÓN MALLOC
    l->head=l->tail=NULL;   //APUNTA LOS APUNTADORES DE LA CABEZA Y LA COLA DE LA PILA A NULO
    l->num=0;   //IGULA EL CONTADOR DE LA PILA A CERO; INICIA EL CONTADOR EN CERO
    return l;   //RETORNA EL APUNTADOR DE LA PILA
}

void liberar_pila(pila *l)  //FUNCIÓN liberar_pila PARA LIBERAR MEMORIA DE LA PILA, PARÁMETROS: VARIABLE APUNTADOR TIPO pila; APUNTADOR A LA PILA
{
    if(l==NULL) return; //RETORNA NULO EN CASO DE QUE LA PILA NO EXISTA
    if(es_vacia(l))     //CODICIÓN PARA LIBERAR MEMORIA DE LA PILA; LA PILA DEBE ESTAR VACÍA
    {
        free(l);    //LIBERA LA MEMORIA RESERVADA DE LA VARIABLE PILA
        l=NULL; //APUNTA A NULO LA VARIABLE DE LA PILA
        return;  //TERMINA LA FUNCIÓN
    }
    else   //LA PILA TIENE ELEMENTOS
    {
        vaciar(l);  //LLAMA A LA FUNCIÓN vaciar PARA VACIAR LA PILA
        free(l);    //LIBERA LA MEMORIA RESERVADA DE LA VARIABLE PILA
        l=NULL; //APUNTA A NULO LA VARIABLE DE LA PILA
        return; //TERMINA LA FUNCIÓN
    }
}

bool push(pila *l, INFO info)
{
    /*FUNCIÓN push PARA INSERTAR UN NODO EN LA PARTE SUPERIOR DE LA PILA,
    PARÁMETROS: VARIBALE APUNTADOR TIPO pila; APUNTADOR A LA PILA, VARIABLE TIPO INFO, INFORMACIÓN DE NODO*/

    nodo* nuevo=crear_nodo(info);   //DECLARA Y CREA UN NODO NUEVO CON LA FUNCIÓN crear_nodo
    if(l->head == NULL && l->tail==NULL)    //CONDICIÓN PARA INSERTAR SI LA PILA ESTA VACÍA, EL APUNTADOR A CABEZA Y LA COLA APUNTAN A NULO
    {
        l->head=l->tail=nuevo;  //LOS APUNTADORES A LA CABEZA Y COLA DE LA PILA APUNTAN AL NUEVO Y ÚNICO NODO
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA PILA EN UNO
        return true;    //TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    else    //EXISTE ALMENOS UN NODO EN LA PILA
    {
        nuevo->sig=l->head; //IGUALA EL APUNTADOR AL SIGUIENTE NODO DEL NODO NUEVO A LA CABEZA
        l->head=nuevo;  //IGULA EL APUNTADOR CABEZA AL NUEVO NODO; RECORRE EL APUNTADOR DE LA CABEZA DE LA PILA AL NODO NUEVO
        l->num++;   //AUMENTA EL CONTADOR DE NODOS DE LA PILA EN UNO
        return true;    //TERMINA LA FUNCIÓN HABIENDO INSERTADO UN NODO, RETORNA TRUE
    }
    return false;   //RETORNA FALSE EN CASO DE NO CUMPLIR ALGUNA DE LAS CONDICIONES ANTERIORES
}

void pop(pila *l)   //FUNCIÓN pop PARA ELIMINAR EL NODO DE LA PARTE SUPERIOR DE LA PILA, PARÁMETROS: VARIABLE APUNTADOR TIPO pila, APUNTADOR A LA PILA
{
    if(es_vacia(l)) return; //CONDICIÓN PARA RETORNAR EL CONTROL A LA FUNCIÓN QUE LA MANDO LLAMAR SI LA PILA ESTÁ VACÍA; NO ELIMINA
    nodo* temporal=l->head; //DECLARA Y CREA UN NODO TEMPORAL Y LO IGUALA A LA CABEZA DE LA PILA
    l->head=l->head->sig;   //IGUALA EL APUNTADOR DE LA CABEZA DE LA PILA AL NODO QUE APUNTA EL APUNTADOR AL SIGUIENTE NODO DE LA CABEZA; RECORRE LA CABEZA AL SIGUIENTE NODO
    temporal->sig=NULL; //IGUALA EL APUNTADOR AL SIGUIENTE NODO DE TEMPORAL A NULO, CONDICIÓN PARA LIBERAR MEMORIA
    liberar_nodo(temporal); //LLAMA LA FUNCIÓN liberar_nodo PARA LIBERAR LA MEMORIA DEL NODO TEMPORAL
    l->num--;   //DECREMENTA EL CONTADOR DE NODOS DE LA PILA EN UNO

}

int localizar(pila *l, INFO info)
{
    /*FUNCIÓN localizar PARA LOCALIZAR UN NODO EN LA PILA,
    PARÁMETROS: VARIABLE APUNTODOR TIPO lista; APUNTADOR A LA PILA, VARIABLE TIPO INFO; INFORMACIÓN DEL NODO*/

    int pos=0;
    if(es_vacia(l)) return -1;  //CONDICIÓN PARA RETORNAR -1 EN CASO DE QUE LA PILA ESTE VACÍA
    nodo *temporal=l->head; //DECLARACIÓN DE UNA VARIABLE APUNTADOR TIPO nodo TEMPORAL IGUALADA A LA CABEZA DE LA PILA
    while(temporal != NULL)     //CICLO WHILE, SE REPITE HASTA QUE LA VARIABLE TEMPORAL SEA IGUAL A NULO
    {
        if(comparar(temporal->info, info)) return pos;  //CONDICIÓN QUE LLAMA A LA FUNCIÓN comparar PARA COMPARAR LA INFORMACIÓN, EN CASO DE SER IGUAL RETORNA EL VALOR DE POS
        pos++; //INCREMENTA EL VALOR DE POS EN UNO
        temporal=temporal->sig; //RECORRE LA VARIABLE TEMPORAL AL SIGUIENTE NODO
    }
    return -1;  //RETORA -1 EN CASO DE NO ENCONTRAR LA INFORMACIÓN EN LA PILA
}

bool comparar(INFO info1, INFO info2)   //FUNCIÓN comparar PARA COMPARAR DOS VARIABLES TIPO INFO, PARÁMETROS: DOS VARIABLES TIPO INFO
{
    if(info1 == info2) return true; //RETORNAR TRUE SI EL VALOR DE LAS VARIABLES ES IGUAL; LA INFORMACIÓN DE LOS NODOS
    return false;   //RETORNA FALSE EN CASO DE QUE EL VALOR DE LAS VARIABLES SEA DIFERENTE
}


bool es_vacia(pila *l)  //FUNCIÓN es_vacia PARA DETERMINAR SI LA PILA ESTÁ VACÍA, PARÁMETROS: VARIABLE APUNTADOR TIPO pila;APUNTADOR A LA PILA
{
    if(l->head == NULL && l->tail == NULL) return true; /*CONDICÓN PARA DETERMINAR SI LA LISTA ESTÁ VACÍA,
    LOS APUTNADORES DE LA CABEZA Y COLA TIENEN QUE APUNTAR A NULO, RETORNA TRUE*/
    return false;   //RETORNA FALSE EN CASO DE QUE LA LISTA NO ESTÉ VACÍA
}

bool vaciar(pila *l)
{
    /*FUNCIÓN vaciar PARA VACIAR LA PILA,
    PARÁMETROS: VARIABLE APUNTADOR TIPO pila; APUNTADOR A LA PILA, ELIMINA DE LA PARTE SUPERIOR A LA INFERIOR*/

    if(es_vacia(l)) return false;   //CONDICIÓN PARA RETORNAR FALSE EN CASO DE QUE LA LISTA ESTÉ VACÍA

    nodo *temporal=l->head; //DECLARA UN APUNTADOR TIPO nodo TEMPORAL Y LA IGUALA A LA CABEZA DE LA PILA
    while(temporal != NULL) //CICLO WHILE, SE REPITE HASTA QUE LA VARIABLE TEMPORAL SEA IGUAL A NULO
    {
        l->head=temporal->sig;  //IGUALA EL APUNTDO DE LA CABEZA AL APUNTADOR AL SIGUIENTE NODO DE TEMPORAL, RECORRE LA CABEZA AL SIGUIENTE NODO
        temporal->sig=NULL; //IGUALA EL APUTNADOR AL SIGUIENTE NODO DE TEMPORAL A NULO, CONDICIÓN PARA LIBERAR MEMORIA DEL NODO
        liberar_nodo(temporal); //LLAMA A LA FUNCIÓN liberar_nodo PARA LIBERAR LA MEMORIA DE TEMPORAL
        temporal=l->head;   //IGUALA TEMPORAL A LA CABEZA
    }
    l->head=l->tail=NULL;   //IGUALA LOS APUNTADORES DE CABEZA Y COLA A NULO
    l->num=0;   //IGUALA EL CONTADOR DE NODOS DE LA LISTA A CERO
    return true;    //RETORNA TRUE, LA PILA SE VACIÓ
}

void imprimir_pila(pila *l) //FUNCIÓN imprimir_pila PARA IMPRIMIR LA PILA, PARÁMTROS: VARIABLE APUNTADOR TIPO pila; APUNTADOR A LA PILA
{
    if(l==NULL) //CODICIÓN PARA EJECUTAR EL BLOQUE EN CASO DE QUE LA PILA APUNTE A NULO, NO EXISTE LA PILA
    {
        printf("NO EXISTE LA LISTA \n");  //MANDA UN MENSAJE AL USUARIO
        return; //TERMINA LA FUNCIÓN
    }
    if(es_vacia(l))   //CONDICIÓN PARA EJECUTAR EL BLOQUE EN CASO DE QUE LA PILA ESTÉ VACÍA
    {
        printf("LISTA VACIA\n"); //MANDA UN MENSAJE AL USUARIO
        return; //TERMINA LA FUNCIÓN
    }
    nodo* t=NULL;   //DECLARA UNA VARIABLE APUNTADOR TIPO nodo Y LA IGUALA A NULO
    for(t=l->head; t != NULL; t=t->sig) //CICLO FOR PARA RECORRER CADA DEL ÚLTIMO AL PRIMERO
    {

        printf("%d->", t->info);    //IMPRIME LA INFORMACIÓN DEL NODO
    }
    return; //TERMINA LA FUNCIÓN

}

int main()  //FUNCIÓN PRICIPAL
{
    int i, r=0, selector, loca; //DECLARACIÓN DE VARIABLES LOCALES TIPO int
    float f;    //DECLARACIÓN DE VARIABLES LOCALES TIPO float
    char c; //DECLARACIÓN DE VARIABLES LOCALES TIPO char
    double d;   //DECLARACIÓN DE VARIABLES LOCALES TIPO double
    pila *l=crear_pila();   //DECLARA Y CREA UNA VARIABLE APUNTADOR TIPO pila CON LA FUNCIÓN crear_pila

    while(r==0) //CICLO WHILE, SE REPITE HASTA QUE EL VALOR DE r SEA DIFERENTE DE 0
    {
        printf("\n\nQue tipo de dato quieres agregar:\n1)int\t\t4)double\n2)float\t\t5)imprimir conjunto\n3)char\t\t6)salir\n"); //MANDA UN MENSAJE
        scanf("%d", &selector); //GUARDA UN VALOR ENTERO EN LA VARIABLE selector

        switch(selector)    //ESTRUCTURA SWITCH
        {
        case 1: //ENTRA AL BLOQUE EN CASO DE QUE EL VALOR DE LA VARIABLE SEA 1
            printf("\nInserte su valor tipo int:"); //MANDA UN MENSAJE AL USUARIO PIDIENDO QUE INSERTE UN VALOR TIPO ENTERO
            scanf("%d", &i);    //GUARDA EL VALOR ENTERO PROPORCIONADO POR EL USUARIO EN LA VARIBLE i
            loca=localizar(l,i);    //LLAMA A LA FUNCIÓN localizar PARA DETERMINAR SI EL VALOR SE ENCUENTRA EN LA PILA/CONJUNTO
            if(loca==-1)    //CONDICÓN PARA EJECUTAR EL BLOQUE EN CASO DE QUE EL VALOR NO ESTE EN LA PILA/CONJUNTO
            {
                push(l,i);  //LLAMA A LA FUNCIÓN push PARA INSERTAR EL VALOR EN LA PILA/CONJUNTO
                break;  //TERMINA EL BLOQUE
            }
            printf("\tEL DATO YA ESTA EN LA LISTA");//MANDA UN MENSAJE AL USUARIO
            break;  //TERMINA EL BLOQUE

        case 2: //ENTRA AL BLOQUE EN CASO DE QUE EL VALOR DE LA VARIABLE SEA 2
            printf("\nInserte su valor tipo float:");
            scanf("%f", &f);    //GUARDA EL VALOR FLOTANTE PROPORCIONADO POR EL USUARIO EN LA VARIBLE f
            printf("\n\tEL VALOR NO PERTENECE AL CONJUNTO");  //MANDA UN MENSAJE AL USUARIO
            break;  //TERMINA EL BLOQUE

        case 3: //ENTRA AL BLOQUE EN CASO DE QUE EL VALOR DE LA VARIABLE SEA 3
            printf("\nInserte su valor tipo char:");    //MANDA UN MENSAJE AL USUARIO
            scanf("%c", &c);    //GUARDA EL VALOR CARACTER PROPORCIONADO POR EL USUARIO EN LA VARIBLE c
            printf("\n\tEL VALOR NO PERTENECE AL CONJUNTO");  //MANDA UN MENSAJE AL USUARIO
            break;  //TERMINA EL BLOQUE

        case 4: //ENTRA AL BLOQUE EN CASO DE QUE EL VALOR DE LA VARIABLE SEA 4
            printf("\nInserte su valor tipo double:");  //MANDA UN MENSAJE AL USUARIO
            scanf("%f", &d);    //GUARDA EL VALOR DOUBLE PROPORCIONADO POR EL USUARIO EN LA VARIBLE d
            printf("\n\tEL VALOR NO PERTENECE AL CONJUNTO");  //MANDA UN MENSAJE AL USUARIO
            break;  //TERMINA EL BLOQUE

        case 5: //ENTRA AL BLOQUE EN CASO DE QUE EL VALOR DE LA VARIABLE SEA 5
            printf("\n*************\n");    //IMPRIME UN SALTO DE LÍNEA SEGUIDO DE ASTERISCOS Y OTRO SALTO DE LÍNEA
            imprimir_pila(l);   //LLAMA A LA FUNCIÓN imprimir_pila
            printf("\n*************");  //IMPRIME UN SALTO DE LÍNEA SEGUIDO DE ASTERISCOS Y OTRO SALTO DE LÍNEA
            break;  //TERMINA EL BLOQUE

        case 6: //ENTRA AL BLOQUE EN CASO DE QUE EL VALOR DE LA VARIABLE SEA 6
            vaciar(l);  //LLAMA A LA FUNCIÓN vaciar
            free(l);    //LLAMA A LA FUNCIÓN free PARA LIBERAR MEMORIA DE LA VARIABLE l
            l=NULL; //IGUALA A NULO l
            r=1;    //IGUALA EL VALOR DE r A 0; CONDICIÓN PARA SALIR DEL BLOQUE
            break;  //TERMINA EL BLOQUE

        }

    }
    printf("\n\nFIN DEL PROGRAMA"); //MANDA UN MENSAJE DE QUE EL PROGRAMA A TERMINADO

    return 0;
}
